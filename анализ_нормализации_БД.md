# Анализ нормализации базы данных

## Текущее состояние схемы

База данных **НЕ полностью соответствует третьей нормальной форме (3NF)**.

## Нарушения 3NF

### 1. Информация о научном руководителе (критическое нарушение)

**Проблема:** Транзитивная зависимость

В таблице `Exhibit` присутствуют поля:
- `supervisor` (ФИО научного руководителя)
- `supervisorPosition` (должность)
- `supervisorRank` (звание)
- `supervisorDepartment` (кафедра)

**Нарушение:** Позиция, звание и кафедра научного руководителя зависят от самого руководителя (supervisor), а не напрямую от экспоната (id).

**Транзитивная зависимость:**
```
id (экспонат) → supervisor → (supervisorPosition, supervisorRank, supervisorDepartment)
```

**Проблемы:**
- Дублирование данных: если один руководитель курирует несколько экспонатов, его должность, звание и кафедра хранятся многократно
- Аномалии обновления: при изменении должности руководителя нужно обновлять все записи экспонатов
- Аномалии удаления: при удалении экспоната теряется информация о руководителе (если это был единственный экспонат)
- Риск несогласованности: возможны расхождения в данных об одном и том же руководителе

### 2. Информация о студенте (потенциальное нарушение)

**Проблема:** Возможная транзитивная зависимость

В таблице `Exhibit` присутствуют поля:
- `studentName` (ФИО студента)
- `studentCourse` (курс)
- `studentGroup` (группа)

**Анализ:**
- Если один студент создает несколько экспонатов в один год, курс и группа должны быть одинаковыми
- Это может указывать на транзитивную зависимость: `id → studentName → (studentCourse, studentGroup)`
- Однако, если студент переходит на следующий курс и создает новый экспонат, курс может измениться, что делает зависимость менее очевидной

**Вывод:** В текущей реализации это может быть приемлемо, так как курс и группа относятся к моменту создания конкретного экспоната, но для полной нормализации лучше вынести в отдельную таблицу.

### 3. JSON поля (технически не нарушение, но плохая практика)

Поля, хранящие JSON в виде строк:
- `images` (String, default "[]")
- `technicalSpecs` (String, default "{}")
- `interestingFacts` (String, default "[]")
- `relatedExhibits` (String, default "[]")

**Проблемы:**
- Нарушение реляционной модели: данные хранятся в неструктурированном виде
- Сложность запросов: нельзя эффективно искать по содержимому JSON полей
- Нет целостности данных: отсутствуют внешние ключи для `relatedExhibits`
- Сложность валидации: нет проверки типов на уровне БД

## Нормализованная схема (3NF)

### Вариант 1: Полная нормализация

```prisma
model Exhibit {
  id                String   @id @default(uuid())
  inventoryNumber   String?
  title             String
  description       String
  fullDescription   String?  @default("")
  creationDate      String?
  dimensions        String?
  currentLocation   String?
  isPublic          Boolean  @default(true)
  
  category          String
  year              String?
  modelPath         String?
  has3DModel        Boolean  @default(false)
  previewImage      String?
  creationInfo      String?  @default("")
  galleryPositionX  Float?
  galleryPositionY  Float?   @default(0)
  galleryPositionZ  Float?
  galleryScale       Float?   @default(1.0)
  galleryRotationY   Float?   @default(0)
  visibleInGallery   Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Связи
  studentId         String?
  student           Student? @relation(fields: [studentId], references: [id])
  supervisorId      String?
  supervisor        Supervisor? @relation(fields: [supervisorId], references: [id])
  
  // Отношения один-ко-многим
  images            ExhibitImage[]
  technicalSpecs    TechnicalSpec[]
  interestingFacts  InterestingFact[]
  relatedExhibits   ExhibitRelation[]

  @@index([category])
  @@index([year])
  @@index([studentId])
  @@index([supervisorId])
  @@index([visibleInGallery])
  @@index([isPublic])
}

model Student {
  id        String    @id @default(uuid())
  name      String
  course    String?
  group     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  exhibits  Exhibit[]

  @@unique([name, course, group])
  @@index([name])
}

model Supervisor {
  id         String    @id @default(uuid())
  name       String
  position   String?
  rank       String?
  department String?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  exhibits   Exhibit[]

  @@unique([name])
  @@index([name])
}

model ExhibitImage {
  id        String   @id @default(uuid())
  exhibitId String
  exhibit   Exhibit  @relation(fields: [exhibitId], references: [id], onDelete: Cascade)
  imagePath String
  order     Int      @default(0)
  createdAt DateTime @default(now())

  @@index([exhibitId])
}

model TechnicalSpec {
  id        String   @id @default(uuid())
  exhibitId String
  exhibit   Exhibit  @relation(fields: [exhibitId], references: [id], onDelete: Cascade)
  key       String
  value     String
  createdAt DateTime @default(now())

  @@unique([exhibitId, key])
  @@index([exhibitId])
}

model InterestingFact {
  id        String   @id @default(uuid())
  exhibitId String
  exhibit   Exhibit  @relation(fields: [exhibitId], references: [id], onDelete: Cascade)
  fact      String
  order     Int      @default(0)
  createdAt DateTime @default(now())

  @@index([exhibitId])
}

model ExhibitRelation {
  id           String   @id @default(uuid())
  exhibitId    String
  exhibit      Exhibit  @relation("ExhibitRelations", fields: [exhibitId], references: [id], onDelete: Cascade)
  relatedId    String
  related      Exhibit  @relation("RelatedExhibits", fields: [relatedId], references: [id], onDelete: Cascade)
  relationType String?  @default("related")
  createdAt    DateTime @default(now())

  @@unique([exhibitId, relatedId])
  @@index([exhibitId])
  @@index([relatedId])
}
```

### Вариант 2: Компромиссный (минимальные изменения)

Если полная нормализация не требуется, можно ограничиться выносом только научных руководителей:

```prisma
model Exhibit {
  // ... все существующие поля кроме supervisor, supervisorPosition, supervisorRank, supervisorDepartment
  
  supervisorId      String?
  supervisor        Supervisor? @relation(fields: [supervisorId], references: [id])
  
  // ... остальные поля
}

model Supervisor {
  id         String    @id @default(uuid())
  name       String
  position   String?
  rank       String?
  department String?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  exhibits   Exhibit[]

  @@unique([name])
  @@index([name])
}
```

## Рекомендации

### Для соответствия 3NF:

1. **Обязательно:** Вынести информацию о научных руководителях в отдельную таблицу `Supervisor`
2. **Желательно:** Вынести информацию о студентах в отдельную таблицу `Student`
3. **Желательно:** Нормализовать JSON поля:
   - `images` → таблица `ExhibitImage`
   - `technicalSpecs` → таблица `TechnicalSpec`
   - `interestingFacts` → таблица `InterestingFact`
   - `relatedExhibits` → таблица `ExhibitRelation` с внешними ключами

### Преимущества нормализации:

- ✅ Устранение дублирования данных
- ✅ Устранение аномалий обновления и удаления
- ✅ Обеспечение целостности данных через внешние ключи
- ✅ Улучшение производительности запросов (индексы на связях)
- ✅ Упрощение поддержки и масштабирования

### Недостатки нормализации:

- ⚠️ Усложнение структуры БД
- ⚠️ Необходимость миграции существующих данных
- ⚠️ Более сложные JOIN запросы (но Prisma упрощает это)
- ⚠️ Необходимость обновления кода приложения

## Вывод

Текущая схема **НЕ соответствует 3NF** из-за транзитивных зависимостей в информации о научных руководителях. Для полного соответствия 3NF необходимо провести нормализацию, вынеся связанные сущности в отдельные таблицы.
